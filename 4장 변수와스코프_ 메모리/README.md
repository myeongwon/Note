
# 변수와 스코프 , 메모리

## 1. 원시값과 참조값
변수는 
	- 원시 값 : 단순한 데이터
	- 참조 값 : 메모리에 저장된 객체.

자바스크립트는 메모리 위치에 직접 접근하는 것을 허용하지 않으므로 객체의 메모리 공간을 직접 조작하는 일은 불가능.
객체를 조작할 때는 사실 객체 자체가 아니라 해당 객체에 대한 참조를 조작하는 것.

### 1.1 동적 프로퍼티 
참조 값을 다룰 때는 프로퍼티와 메서드를 추가하거나 바꾸고 삭제 할수 있음.


### 1.2 값복사.
원시값을 다른 변수로 복사 할대는 현재 저장된 값을  새로 생성한 다음 새로운 변수에 복사.

참조값을 변수에서 다른 변수로 복사하면 원래 변수에 들어있던 값값이 다른 변수에 복사되기는 마찬가지.

차이는 **그 값이 객체 자체가 아닌 힙(heap)에 저장된 객체를 가리키는 포인터**라는 점. 
한쪽을 조작하면 다른 쪽에도 반영됩니다.

```js
var obj1 = new Object();
var obj2 = obj1;
obj1.name = 'nic';
console.log(obj2.name); // nic 
```

###1.3 매개변수 전달
ECMAScript 의 함수 매개변수는 모두 값으로 전달됩니다.
매개변수는 오직 값으로만 전달. 

매개변수를 값 형태로 넘기면 해당 값은 지역변수에 복사.
즉 이름 붙은 매개변수로 복사되면 ECMAScript에서는 arguments 객체의 한 자리를 차지함. 

```js
	function addTen(num){
	num +=10;
	return num;
}

var count = 20;
var result = addTen(count);
console.log(count); //20
console.log(result); //30 

```

### 1.4 타입판별
**typeof연산자**는 변수가 원시 타입인지 파악하기에 최상
null, 값이 객체는 'object'를 반환한다. 

```js
var n = null;
console.log(typeof n); //object
```

**instanceof 연산자**는 변수가 주어진 참조타입의 인스턴스일때. true를 반환 



##2. 실행 컨텍스트와 스코프 

가장 바깥쪽에 존재하는 실행 컨텍스트는 전역 컨텍스트.

전역변수와 함수는 모두 window객체 프로퍼티 및 메서드로 생성됨.

함출호출시 독자적인 실행 컨텍스트 생성.
코드 실행이 함수로 들어갈 때마다 함수의 컨텍스트가 컨텍스트 스택에 쌓임. 
함수실행이 끝나면 해당 컨텍스트를 스택에서 꺼내고 컨트롤을 이전 컨텍스트에 반환.



컨텍스트에서 코드를 실행하면 변수 객체에 스코프 체인이 생성됨. 
스코프체인의 목적은 실행 컨텍스트가 접근 할수 있는 모든 변수와 함수에 순서를 정의하는 것. 

##2.1 스코프 체인확장 
##2.2 자바스크립트에는 블록레벨 스코프가 없음.

##3. 가바지 콜렉션
자바스크립트는 실행 환경에서 코드 실행 중에 메모리를 관리. 

###3.1 표시하고 지우기
널리 쓰이는 가비지 컬렉션 방법은 표시하고 지우기
컨텍스트안에 존재하는 변수의 메모리는 해체해서는 안되는데,
해당 컨텍스트가 실행 중인 한. 사용될 가능성이 있기 때문임.


###3.2 참조카운팅 
###3.3 성능
###3.4 메모리관리
웹브라우저에서 사용할수 있는 메모리는 
일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적다.

가능한 최소한의 메모리만 사용해야 페이지 성능을 올릴수 있음. 메모리 사용을 최적화하는 가장 좋은 코드 실행에 필요한 데이터만 유지하는 것입니다. 
필요없어진 데이터에는 **null** 을 할당하여 참조를 제거하는 편이 좋다. 

```js
function createPerson(name){
	var localPerson = new Object();
	localPerson.name = name;
	return localPerson;
}

var globalPerson = createPerson('nic');
//golobalPerson을 사용하는 코드
globalPerson = null;
```













